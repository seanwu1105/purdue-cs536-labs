# Problem 1 [70 pts]

## 1.1 System set-up, traffic generation, and capture

In this problem, you will sniff Ethernet frames on an Ethernet interface _veth0_
on one of the pod machines in LWSN B148. When sniffing Ethernet frames, you are
putting the interface in promiscuous mode which requires superuser privilege to
do so. On a pod machine, run

```sh
sudo /usr/local/etc/tcpdumpwrap-veth0 -c 12 -w - > testlogfile
```

which will capture 12 Ethernet frames and save them into `testlogfile`. Enter
your password when prompted. `tcpdumpwrap-veth0` is a wrapper of `tcpdump` that
allows sudo execution. Check the man page of `tcpdump` for available options. To
generate traffic arriving on _veth0_, use the ping app from Problem 1, lab2,
with server `mypingsrv` running on a pod machine bound to IP address
`192.168.1.1`. The client, `mypingcli`, is executed from the same machine using

```sh
veth 'mypingcli 192.168.1.2 192.168.1.1 srv-port'
```

where `veth`, similar to our remote-command execution app from Problem 2, lab2,
executes `mypingcli` at a machine with IP address `192.168.1.2`. Thus the client
transmits/receives packets on interface `192.168.1.2`, and the server
transmits/receives traffic through interface `192.168.1.1`. `192.168.1.1` is a
private IP address that is not routable on the global IP Internet which has been
configured for _veth0_. `192.168.1.2` is the IP address at the opposite end of
veth0 as if the two interfaces were connected by a point-to-point Ethernet link.

For security reasons, we cannot perform sniffing on _eth0_ which is the
interface through which the lab machines, a shared resource, are connected to
the Internet. Therefore we use dummy/virtual interfaces in Linux that allows
veth0 to be configured as a separate Ethernet interface -- albeit virtual, not
physical -- with private IP address `192.168.1.1` that can reach `192.168.1.2`,
and vice versa. Thus performing `veth` at `192.168.1.2` on a pod machine does
not execute `mypingcli` on a different physical machine equipped with an
Ethernet interface _veth0_ with IP address `192.168.1.2`. Instead, both server
`mypingsrv` and client mypingcli run on the same physical machine, and packet
forwarding is handled virtually by Linux as if `192.168.1.2` were a physical
Ethernet interface on a separate machine. For our Ethernet frame sniffing and
inspection exercise, this will suffice.

## 1.2 Traffic analysis

Use parameters for mypingcli from Problem 1, lab2, so that at least 12 Ethernet
frames are generated by the ping client/server app which will be captured by
`tcpdumpwrap-veth0`. After doing so, analyze `testlogfile` using wireshark or
`tcpdump` (`tcpdump` is also an analysis tool). Wireshark
(`/usr/bin/wireshark-gtk`), the postcursor of ethereal, is a popular graphical
tool for analyzing (as well as capturing) traffic logs in pcap format. Use
wireshark or `tcpdump` to inspect the 12 captured Ethernet frames. Using the MAC
address associated with `192.168.1.1` (perform `ifconfig -a` on a pod machine)
and the MAC address associated with `192.168.1.2` (perform `veth 'ifconfig -a'`
on the same pod machine), identify the relevant Ethernet frames whose payload
are IPv4 packets that, in turn, contain UDP packets generated by the ping app,
as their payload. Check the type field of the captured Ethernet frames to
confirm that they are DIX frames.

The first 20 bytes of Ethernet payload comprise IP header and the next 8 bytes
the UDP header. The last 8 bytes of the IP header specify the source IP address
and the destination IP address. Check their values against the IP addresses used
by the ping app. The first four bytes of the UDP header specify the source and
destination ports. Check that they match the port numbers used by the ping app.
Inspect the remaining bytes of the captured Ethernet frames which comprise the
application layer payload that `mypingcli` and `mypingsrv` sent using
`sendto()`. For example, the client request is 5 bytes long comprised of a
4-byte sequence number and 1-byte control field. Wireshark/`tcpdump` will
provide output where Ethernet header fields (MAC addresses and type) are
decoded. Inspect the captured raw data in hexadecimal form to match the IPv4
addresses and UDP port numbers. Use wireshark/`tcpdump` as a confirmation tool.
Do the same when analyzing the application layer payload carried by the Ethernet
frames. Discuss your findings in `lab3.pdf`.

Note: To run `tcpdump`, please use the command, `tcpdump -r - < testlogfile`,
instead of, `tcpdump -r testlogfile`, which will trigger an "access denied"
error. As noted in class, you may also run the command-line version of
wireshark, `/usr/bin/tshark`, instead of `tcpdump`. To run wireshark, you will
have to be physically at a lab machine. If you prefer, you may install wireshark
on a Windows, MacOS, or Linux machine, copy testlogfile to the machine and run
wireshark to inspect captured frames.

## MAC Addresses

We get the interface config of the pod3-3 machine:

```txt
pod3-3 51 $ ifconfig -a
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 128.10.25.213  netmask 255.255.255.0  broadcast 128.10.25.255
        inet6 fe80::16b3:1fff:fe02:3e08  prefixlen 64  scopeid 0x20<link>
        ether 14:b3:1f:02:3e:08  txqueuelen 1000  (Ethernet)
        RX packets 893518410  bytes 1018870968114 (1.0 TB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 363304891  bytes 127058012388 (127.0 GB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
        device interrupt 16  memory 0xf7200000-f7220000

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 3279754  bytes 727661013 (727.6 MB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 3279754  bytes 727661013 (727.6 MB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

veth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.1.1  netmask 255.255.255.0  broadcast 192.168.1.255
        inet6 fe80::60b5:6dff:fea1:dbb  prefixlen 64  scopeid 0x20<link>
        ether 62:b5:6d:a1:0d:bb  txqueuelen 1000  (Ethernet)
        RX packets 1814  bytes 120758 (120.7 KB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 3478  bytes 461386 (461.3 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

Thus, the MAC address of _veth0_ used by `mypingsrv` is `62:b5:6d:a1:0d:bb`.

We get the virtual interface config of the pod3-3 machine:

```txt
pod3-3 52 $ veth 'ifconfig -a'
lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

veth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.1.2  netmask 255.255.255.0  broadcast 192.168.1.255
        inet6 fe80::4c2:5fff:fe25:ea64  prefixlen 64  scopeid 0x20<link>
        ether 06:c2:5f:25:ea:64  txqueuelen 1000  (Ethernet)
        RX packets 3482  bytes 462238 (462.2 KB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1814  bytes 120758 (120.7 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

Thus, the MAC address of _veth0_ used by `mypingcli` is `06:c2:5f:25:ea:64`.

## Traffic Logging

We use `mypingcli` to interact with `mypingsrv`. The contents of `pingparam`
are:

- N: 5
- T: 2
- D: 1
- S: 0

The following is the contents of `testlogfile` collected by `tcpdump`:

```txt
pod3-3 55 $ tcpdump -XX -n -r - < testlogfile
reading from file -, link-type EN10MB (Ethernet)
10:35:57.121253 IP 192.168.1.2.59727 > 192.168.1.1.22222: UDP, length 5
	0x0000:  62b5 6da1 0dbb 06c2 5f25 ea64 0800 4500  b.m....._%.d..E.
	0x0010:  0021 3ad5 4000 4011 7ca3 c0a8 0102 c0a8  .!:.@.@.|.......
	0x0020:  0101 e94f 56ce 000d 8372 0000 0000 01    ...OV....r.....
10:35:58.121470 IP 192.168.1.1.22222 > 192.168.1.2.59727: UDP, length 5
	0x0000:  06c2 5f25 ea64 62b5 6da1 0dbb 0800 4500  .._%.db.m.....E.
	0x0010:  0021 d963 4000 4011 de14 c0a8 0101 c0a8  .!.c@.@.........
	0x0020:  0102 56ce e94f 000d 8372 0000 0000 01    ..V..O...r.....
10:35:59.121321 IP 192.168.1.2.59727 > 192.168.1.1.22222: UDP, length 5
	0x0000:  62b5 6da1 0dbb 06c2 5f25 ea64 0800 4500  b.m....._%.d..E.
	0x0010:  0021 3b5b 4000 4011 7c1d c0a8 0102 c0a8  .!;[@.@.|.......
	0x0020:  0101 e94f 56ce 000d 8372 0100 0000 01    ...OV....r.....
10:36:00.121569 IP 192.168.1.1.22222 > 192.168.1.2.59727: UDP, length 5
	0x0000:  06c2 5f25 ea64 62b5 6da1 0dbb 0800 4500  .._%.db.m.....E.
	0x0010:  0021 db2e 4000 4011 dc49 c0a8 0101 c0a8  .!..@.@..I......
	0x0020:  0102 56ce e94f 000d 8372 0100 0000 01    ..V..O...r.....
10:36:01.121417 IP 192.168.1.2.59727 > 192.168.1.1.22222: UDP, length 5
	0x0000:  62b5 6da1 0dbb 06c2 5f25 ea64 0800 4500  b.m....._%.d..E.
	0x0010:  0021 3cb5 4000 4011 7ac3 c0a8 0102 c0a8  .!<.@.@.z.......
	0x0020:  0101 e94f 56ce 000d 8372 0200 0000 01    ...OV....r.....
10:36:02.121717 IP 192.168.1.1.22222 > 192.168.1.2.59727: UDP, length 5
	0x0000:  06c2 5f25 ea64 62b5 6da1 0dbb 0800 4500  .._%.db.m.....E.
	0x0010:  0021 dc8d 4000 4011 daea c0a8 0101 c0a8  .!..@.@.........
	0x0020:  0102 56ce e94f 000d 8372 0200 0000 01    ..V..O...r.....
10:36:02.230216 ARP, Request who-has 192.168.1.1 tell 192.168.1.2, length 28
	0x0000:  62b5 6da1 0dbb 06c2 5f25 ea64 0806 0001  b.m....._%.d....
	0x0010:  0800 0604 0001 06c2 5f25 ea64 c0a8 0102  ........_%.d....
	0x0020:  0000 0000 0000 c0a8 0101                 ..........
10:36:02.230267 ARP, Reply 192.168.1.1 is-at 62:b5:6d:a1:0d:bb, length 28
	0x0000:  06c2 5f25 ea64 62b5 6da1 0dbb 0806 0001  .._%.db.m.......
	0x0010:  0800 0604 0002 62b5 6da1 0dbb c0a8 0101  ......b.m.......
	0x0020:  06c2 5f25 ea64 c0a8 0102                 .._%.d....
10:36:03.121535 IP 192.168.1.2.59727 > 192.168.1.1.22222: UDP, length 5
	0x0000:  62b5 6da1 0dbb 06c2 5f25 ea64 0800 4500  b.m....._%.d..E.
	0x0010:  0021 3d1e 4000 4011 7a5a c0a8 0102 c0a8  .!=.@.@.zZ......
	0x0020:  0101 e94f 56ce 000d 8372 0300 0000 01    ...OV....r.....
10:36:03.254177 ARP, Request who-has 192.168.1.2 tell 192.168.1.1, length 28
	0x0000:  06c2 5f25 ea64 62b5 6da1 0dbb 0806 0001  .._%.db.m.......
	0x0010:  0800 0604 0001 62b5 6da1 0dbb c0a8 0101  ......b.m.......
	0x0020:  0000 0000 0000 c0a8 0102                 ..........
10:36:03.254200 ARP, Reply 192.168.1.2 is-at 06:c2:5f:25:ea:64, length 28
	0x0000:  62b5 6da1 0dbb 06c2 5f25 ea64 0806 0001  b.m....._%.d....
	0x0010:  0800 0604 0002 06c2 5f25 ea64 c0a8 0102  ........_%.d....
	0x0020:  62b5 6da1 0dbb c0a8 0101                 b.m.......
10:36:04.121810 IP 192.168.1.1.22222 > 192.168.1.2.59727: UDP, length 5
	0x0000:  06c2 5f25 ea64 62b5 6da1 0dbb 0800 4500  .._%.db.m.....E.
	0x0010:  0021 de50 4000 4011 d927 c0a8 0101 c0a8  .!.P@.@..'......
	0x0020:  0102 56ce e94f 000d 8372 0300 0000 01    ..V..O...r.....
```

We ignore the ARP frames, focusing only on the IP packages. The first packets
has the following contents:

```txt
62b5 6da1 0dbb 06c2 5f25 ea64 0800 4500
0021 3ad5 4000 4011 7ca3 c0a8 0102 c0a8
0101 e94f 56ce 000d 8372 0000 0000 01
```

The first 14 bytes are the header of the Ethernet frame. Inside the header, the
first 6 bytes represent the destination MAC address. In this pinging case, the
target MAC address is server's address, `62:b5:6d:a1:0d:bb`.

```txt
62 B5 6D A1 0D BB
```

The next 6 bytes represent the source MAC address, which is the client's
address, `06:c2:5f:25:ea:64`.

```txt
06 C2 5F 25 EA 64
```

According to the DIX (Ethernet II) spec, the next 4 bytes represent the type of
the payload (EtherType). In our ping application, we only use IPv4. The
EtherType of IPv4 is `0x0800`, which matches our experiment.

```txt
08 00
```
